import os
import sys
import json
import string

global FLAGS
FLAGS = {"-v": False}
global PRJ_NAME
DYLIB_DIR =""
BANNER    ="\
##########################################################\n\
## THIS FILE WAS AUTO GENERATED BY THE BINDWRITER TOOL  ##\n\
##                                                      ##\n\
## ANY ALTERATIONS OF THIS FILES CONTENTS MAY CAUSE     ##\n\
## UNEXPECTED BEHAVIOUR                                 ##\n\
##########################################################\n\
## File Usage: Import DLL and wrap its exposed          ##\n\
## functions and classes                                ##\n\
##########################################################\n\n"


def vPrint(fmt):
    #if FLAGS["-v"]:
    print(f"{fmt}")

class File:
    def __init__(self, path):
        self.fpath = path

        self.HEADER         = ""
        self.FUNC_DEFS      = "## FUNC DEFS ##\n"
        self.CLS_MFUNC_DEFS = "## MEMBER FUNC DEFS ##\n"
        self.CLASS_DEFS     = "## CLASS DEFS ##\n"

        self.ILEVEL = 0

    def app(self, section: str, fmt):
        '''
        Appends a formatted string to a specific section of the file

        section: 
            "h"   - Head of file

            "fd"  - Function definitions

            "cfd" - class function definitions

            "cd"  - class definitions

        fmt: 
        The string to be appended
        '''
        match section:
            case "h":
                self.HEADER += fmt
            case "fd":
                self.FUNC_DEFS += fmt
            case "cfd":
                self.CLS_MFUNC_DEFS += fmt
            case "cd":
                self.CLASS_DEFS += fmt

    def write(self):
        with open(self.fpath, 'w') as f:
            
            write = self.HEADER + '\n' + self.FUNC_DEFS +  '\n' \
            + self.CLS_MFUNC_DEFS + '\n' + self.CLASS_DEFS

            #vPrint(write)
            f.write(write)

            vPrint(f"Wrote changes to file: {f.name}")


    def calc_indention(self):
        return ('\t'*self.ILEVEL)
    
    def indent(self):
        self.ILEVEL += 1

    def dedent(self):
        if self.ILEVEL != 0: self.ILEVEL -= 1
    
    def reset_indent(self, to=0):
        self.ILEVEL = to


#is Constructor/Deconstructor
def IsCD(fn):
    if "PyCreate" in fn['name']:
        return "Con"
    elif "PyDestroy" in fn['name']:
        return "Des"
    else: return False


def gen_doc(jdta, file):
    doc = "\n\"\"\""
    doc += jdta['description']
    doc += "\"\"\""
    doc += "\n\n"
    file.app("h", doc)

def gen_util(file):
    util = "## Util ##\n"
    util += "\n\
def to_cint(i):\n\t\
    return ctypes.c_int(i)\n\
def to_cstr(fmt):\n\t\
    return bytes(fmt, \"utf8\")\n\n"
    file.app("h", util)


def gen_func_sig(fndat, file, mfn=False):
    global PRJ_NAME
    NEEDS_WRITE = False
    name = fndat['name']
    params = fndat['params']
    ret_type = fndat['return']
    print(f'GEN FN> {name}')

    if ret_type  ==  " ":
        ret_type = ""
    else:
        NEEDS_WRITE = True

    params_write = ''
    if params[0] == " ":
        params_write = ""

    else: 
        NEEDS_WRITE = True
        params_write += '['
        for p in params:
            # SELF token reps a class instance ptr
            if p == "SELF":
                params_write += "ctypes.c_void_p, "
                continue
            else:
                params_write += f"ctypes.{p}, "
        params_write = params_write[:-2]  # remove trailing comma
        params_write += ']'

    fnwrite = f"''' Func {name} '''\n"
    if NEEDS_WRITE:
        # generate func sig
        if ret_type != "":
            fnwrite += f"{PRJ_NAME}.{name}.restype = ctypes.{ret_type[0]}\n"
        if params_write != "":
            fnwrite += f"{PRJ_NAME}.{name}.argtypes = {params_write}\n"

    # not a member func
    if mfn == False:
        args: str = ""
        
        # if there are more than one args, it will just 
        # append a letter to the end of each
        if len(params) > 0:
            i = 0
            for p in params:
                if p == " ":
                    # no arguments
                    args = "  "
                    continue
                else:
                    args += f"{p}{string.ascii_uppercase[i]}, "
                    i += 1
            args = args[:-2]
            print(args)
        
            fnwrite += f"def {name}({args}):\n\t{PRJ_NAME}.{name}({args})\n"
            print(fnwrite)
            file.app("fd", fnwrite)
    else:
        file.app("cfd", fnwrite)


def gen_class(clsdat, file: File):
    global PRJ_NAME
    NEEDS_INSTANCE = False
    name = clsdat['name']
    funcs = clsdat['mfuncs']

    wclsDef = f"class {name}:\n\t"
    for fn in funcs:
        # generate function decl for class
        gen_func_sig(fn, file, True)
        ty = IsCD(fn)
        if ty == "Con":
            # Generate the class instance
            wclsDef += f"def __init__(self):\n\t\tself.cInstance = {PRJ_NAME}.{fn['name']}()\n\n\t"
        elif ty == "Des":
            wclsDef += f"def __del__(self):\n\t\t{PRJ_NAME}.{fn['name']}(self.cInstance)\n\n\t"

        else:
            defNameI = fn['name'].find("_")
            defName = fn['name'][defNameI + 1:]

            params = fn['params']
            args: str = ""
            
            # if there are more than one args, it will just 
            # append a letter to the end of each
            if len(params) > 0:
                i = 0
                for p in params:
                    if p == "SELF":
                        NEEDS_INSTANCE = True
                        continue
                    else:
                        args += f", {p}{string.ascii_uppercase[i]}"
                    #print(args)
                    i += 1
            if NEEDS_INSTANCE:
                wclsDef += f"def {defName}(self{args}):\n\t\t{PRJ_NAME}.{fn['name']}(self.cInstance{args})\n\n\t"
            else:
                wclsDef += f"def {defName}(self{args}):\n\t\t{PRJ_NAME}.{fn['name']}({args})\n\n\t"

    file.app("cd", wclsDef)

def setup_impdta(jd):
    global PRJ_NAME
    IMPDTA = File(f"{PRJ_NAME}.py")

    IMPDTA.app("h", BANNER)
    gen_doc(jd, IMPDTA)
    gen_util(IMPDTA)
    IMPDTA.app("h", f"import ctypes\n{PRJ_NAME} = ctypes.CDLL('{DYLIB_DIR}')\n\n")
    
    for fn in jd['funcs']:
        gen_func_sig(fn, IMPDTA)
    for cls in jd['class']:
        print(cls['name'])
        gen_class(cls, IMPDTA)

    IMPDTA.write()

def main():
    global DYLIB_DIR, PRJ_NAME, FLAGS
    wrkdir = sys.argv[0];
    os.system('cls')
    for arg in sys.argv[1:]:
        files = []
        match arg:
            case "-v":
                print("Verbose flag enabled")
                FLAGS["-v"] = True
            case _:
                files.append(arg)

        vPrint(f"Working Dir: {wrkdir}")
        for f in files:
            with open(f, 'r') as f:
                data = json.load(f)     
                PRJ_NAME = data['projName']
                DYLIB_DIR =  data['dlldir']
                vPrint(f"== Creating python bridge \"{PRJ_NAME}\" for DLL: {DYLIB_DIR}")
        
                setup_impdta(data)


if __name__ == "__main__":
    main()
    quit()
